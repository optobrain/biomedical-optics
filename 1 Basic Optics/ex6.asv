%% Constants and given values: all lengths are in [um].

clear;

nx = 100;  ny = 80;  % number of sampling points (pixels of the camera)

dxSam = 5;  % the sampling interval on the focal plane [um]

load("virtualTarget.mat","phySamp");  % phySamp : the virtual resolution test target
phySamp = double(phySamp);  % convert the boolean array to a double array for further computation
[nxp,nyp] = size(phySamp);  % size of the physical sample [pixels]
dxp = 0.1;  % um per pixel of the physical sample


%% Manually implement the convolution

% define kernel size
kernSize = round(dxSam/dxp);  % the kernel size in pixels of the virtual sample

% empty array as a resulting image
img = zeros(nx,ny);
ixKernel = 0;  iySamPhy = 0;  % starting position of the sampling kernel
for iy=1:ny
    for ix=1:nx
        % for each (ix,iy)th pixel of the image
        % average the corresponding area (kernel) of the virtual sample
        sam1 = phySamp(ixKernel+(1:kernSize),iySamPhy+(1:kernSize));  % extract the piece of the virtual sample
        img(ix,iy) = mean(sam1(:));  % average the information within the piece
        
        ixKernel = ixKernel + kernSize;  % update ix for the next kernel position in X
    end
    iySamPhy = iySamPhy + kernSize;  ixKernel = 0;  % update iy and ix for the next kernel position
end

figure;  colormap(gray);
imagesc(img');
set(gca,'ydir','normal');
axis image;


%% Use convn()

% define kernel
kern = ones(kernSize,kernSize);
kern = kern/sum(kern(:));  % normalize the kernel when using convn()

% convolution of the phySamp
phySampConv = convn(phySamp,kern,'same');  

% pick the data from the center of each "camera pixel" on the sample plane
dxSamPhy = round(dxSam/dxp);  % the sampling interval in terms of the physical pixel number
img2 = phySampConv(round(dxSamPhy/2):dxSamPhy:end,round(dxSamPhy/2):dxSamPhy:end);

% crop img if it is larger than the FOV
if size(img2,1) > nx
    img2 = img2(1:nx,:);
end
if size(img2,2) > ny
    img2 = img2(:,1:ny);
end

figure;  colormap(gray);
imagesc(img2');
set(gca,'ydir','normal');
axis image;

disp(['Difference between the two methods: ' num2str(mean((img(:)-img2(:)).^2),3)]);


%% Resolution

% visually, 2^6=64 pixels or 6.4-um pattern (6-dots column) is clear.  Thus, the resolution is better than 6.4 um, similar to the kernel size 5 um.

% 2^5 = 32-pixel pattern is hard to judge.  we can plot.

ix64 = 13;  % the center X position of the 6.4-um pattern
ix32 = 8; 

figure;
subplot(211);  plot(img2(ix64,:));
subplot(212);  plot(img2(ix32,:));

% we can see 3 peaks in 6.4-um but not in 3.2-um patterns.




